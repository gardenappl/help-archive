#!/bin/sh

set -o errexit


# Sanitize string so it's usable as an argument
shell_quote() {
	# Escape single quotes
	escaped=$(echo "$1" | sed "s/'/'\"'\"'/g")

	case "$escaped" in
		'' )
			# Empty string
			;;
		*[![:alnum:]_\./~-]* )
			# Argument is not clean, needs quoting
			echo "'$escaped'"
			;;
		* )
			# Argument contains only safe characters
			echo "$escaped"
			;;
	esac
}

simplify_home() {
	echo "$1" | awk -v home="$HOME" '{ sub("^"home, "~"); print }'
}


options=ho:X:p:fdqscS
longopts=help,output-directory:,extract-to:,password:,force,force-overwrite,delete,quiet,force-skip,skip,command,simulate
parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
eval set -- "$parsed"


while true; do
	case "$1" in 
		-o | --output-directory | -X | --extract-to )
			# Get rid of trailing slash
			output_dir="${2%/}"
			shift 2
			;;
		-p | --password )
			password="$2"
			shift 2
			;;
		-f | --force-overwrite | --force )
			force=y
			shift
			;;
		-s | --force-skip | --skip )
			skip=y
			shift
			;;
		-d | --delete )
			delete=y
			shift
			;;
		-q | --quiet )
			quiet=y
			shift
			;;
		-c | --command | -S | --simulate )
			only_print_command=y
			shift
			;;
		-- )
			shift
			archive_path="$1"
			break
			;;
	esac
done

if [ -n "$force" ] && [ -n "$skip" ]; then
	>&2 echo "Error: can't --skip and --force-overwrite at the same time."
	exit 1
fi


# Helper function for tools like xzcat, bzcat
# If the path to archive contains slashes (e.g. 'dir/file.xz')
# then force outputting to current directory, as opposed to 'dir/file'
force_output_dir_to_current_dir() {
	if [ -z "$output_dir" ]; then
		case "$archive_path" in
			*/* )
				output_dir='.'
				;;
		esac
	fi
}


# We will manually replace ARCHIVE_PATH, etc with the needed arguments
# (with or without color formatting)

case "$archive_path" in
	*.zip )
		handle_delete_manually=y

		run="unzip"

		[ -n "$force" ] && run="$run -o"
		[ -n "$skip" ] && run="$run -n"
		[ -n "$quiet" ] && run="$run -q"
		
		# Handle password which starts with -
		case "$password" in
			'' )
				# No password
				;;
			-* )
				run="$run -PPASSWORD"
				;;
			* )
				run="$run -P PASSWORD"
				;;
		esac

		# Info-ZIP does not recognize --
		archive_path_handle_dash=leading-dot
		run="$run ARCHIVE_PATH"

		[ -n "$output_dir" ] && run="$run -d OUTPUT_DIR"
		;;
	*.rar )
		handle_delete_manually=y

		run="unrar x"

		[ -n "$force" ] && run="$run -o+"
		[ -n "$skip" ] && run="$run -o-" # Skips files but sometimes exits with an error anyway, sigh...
		[ -n "$quiet" ] && run="$run -idq"
		[ -n "$password" ] && run="$run -pPASSWORD"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"

		# unrar always treats the last argument as the output dir,
		# but only if it has a trailing slash
		if [ -n "$output_dir" ]; then
			output_dir="$output_dir/"
			run="$run OUTPUT_DIR"
		fi
		;;
	*.tar | *.tar.* | *.tgz | *.tbz | *.txz | *.tlz | *.tzo )
		handle_delete_manually=y
		handle_output='mkdir'

		case "$archive_path" in
			*.tar.gz | *.tgz )
				[ -n "$quiet" ] && run="tar xzf" || run="tar xzvf"
				;;
			*.tar.bz | *.tbz )
				[ -n "$quiet" ] && run="tar xjf" || run="tar xjvf"
				;;
			* )
				[ -n "$quiet" ] && run="tar xf" || run="tar xvf"
				;;
		esac

		# Handle archive path which starts with -
		# We put the --directory argument at the end, so we can't use --
		archive_path_handle_dash=leading-dot
		run="$run ARCHIVE_PATH"

		[ -n "$skip" ] && run="$run --skip-old-files"
		[ -z "$skip" ] && [ -z "$force" ] && run="$run -k"
		[ -n "$output_dir" ] && run="$run --directory=OUTPUT_DIR"
		;;
	?*.bz2 | ?*.bz | ?*.gz | ?*.xz | ?*.lzma | ?*.lz )
		handle_output='mkdir'
		handle_skip_manually=y

		case "$archive_path" in
			*.bz )
				remove_suffix='.bz'
				run_unzip="bunzip2"
				run_cat="bzcat"
				;;
			*.bz2 )
				remove_suffix='.bz2'
				run_unzip="bunzip2"
				run_cat="bzcat"
				;;
			*.gz )
				remove_suffix='.gz'
				run_unzip="gunzip"
				run_cat="zcat"
				;;
			*.xz )
				remove_suffix='.xz'
				run_unzip="unxz"
				run_cat="xzcat"
				;;
			*.lzma )
				remove_suffix='.lzma'
				run_unzip="unlzma"
				run_cat="lzcat"
				;;
			*.lz )
				remove_suffix='.lz'
				run_unzip="lzip -d"
				run_cat="lzip -d --stdout"
		esac

		force_output_dir_to_current_dir
		archive_path_handle_dash=double-dash

		if [ -n "$output_dir" ]; then
			handle_delete_manually=y
			handle_force=noclobber
			run="$run_cat ARCHIVE_PATH > OUTPUT_PATH"
		else
			run="$run_unzip"
			[ -z "$delete" ] && run="$run --keep"
			[ -n "$force" ] && run="$run --force"
			run="$run ARCHIVE_PATH"
		fi
		;;
	?*.lzo )
		handle_skip_manually=y
		handle_output='mkdir'

		run="lzop -x"

		[ -n "$delete" ] && run="$run --delete"
		[ -n "$force" ] && run="$run --force"
		if [ -n "$skip" ]; then
			echo "Sorry, the --skip is not supported for lzop." >&2
			exit 1
		fi

		output_dir_handle_dash=leading-dot
		[ -n "$output_dir" ] && run="$run --path=OUTPUT_DIR"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
	?*.Z )
		handle_skip_manually=y
		handle_output='mkdir'

		remove_suffix='.Z'
		run="uncompress"

		force_output_dir_to_current_dir

		# Let's be strictly POSIX-compliant in the case of .Z
		archive_path_handle_dash=leading-dot
		if [ -z "$delete" ] || [ -n "$output_dir" ]; then
			handle_delete_manually=y
			handle_force=noclobber
			run="uncompress -c ARCHIVE_PATH > OUTPUT_PATH"
		elif [ -n "$force" ]; then
			run="uncompress -f ARCHIVE_PATH"
		else
			run="uncompress ARCHIVE_PATH"
		fi
		;;
	* )
		case "$archive_path" in
			*.7z )
				# Using 7z is perfectly fine
				;;
			* )
				>&2 echo "Don't know the proper tool for $archive_path, let's just try 7z"
				;;
		esac

		handle_delete_manually=y

		run="7z x"

		[ -n "$force" ] && run="$run -aoa"
		[ -n "$skip" ] && run="$run -aos"
		[ -n "$output_dir" ] && run="$run -oOUTPUT_DIR"
		[ -n "$password" ] && run="$run -pPASSWORD"
		[ -n "$quiet" ] && run="$run -bd"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
esac

# Manually check if file exists
if [ -n "$handle_skip_manually" ] && [ -n "$skip" ]; then
	# We still have to --delete even if we manually skip.
	# handle_delete_manually is handled later.
	if [ -n "$delete" ] && [ -z "$handle_delete_manually" ]; then
		run="([ -e OUTPUT_PATH ] && rm ARCHIVE_PATH) || $run"
	else
		run="[ -e OUTPUT_PATH ] || $run"
	fi
	used_or=y
fi

# Manually remove archive on successful extraction
if [ -n "$handle_delete_manually" ] && [ -n "$delete" ]; then
	if [ -n "$used_or" ]; then
		run="($run) && rm ARCHIVE_PATH"
	else
		run="$run && rm ARCHIVE_PATH"
	fi
fi

# 'set -o noclobber' to prevent overwriting files by default
if [ "$handle_force" = 'noclobber' ] && [ -z "$force" ] && [ -z "$skip" ]; then
	run="$(printf 'set -o noclobber\n%s' "$run")"
fi

# Manually create output directory
if [ "$handle_output" = 'mkdir' ] && [ -n "$output_dir" ]; then
	# Handle output dir which starts with -
	case "$output_dir" in
		. )
			;;
		-* )
			run="$(printf 'mkdir -p -- OUTPUT_DIR\n%s' "$run")"
			;;
		* )
			run="$(printf 'mkdir -p OUTPUT_DIR\n%s' "$run")"
			;;
	esac
fi


case "$archive_path" in
	-* )
		if [ "$archive_path_handle_dash" = 'double-dash' ]; then
			archive_path_arg_prefix="-- "
		elif [ "$archive_path_handle_dash" = 'leading-dot' ]; then
			archive_path="./$archive_path"
		fi
		;;
	* )
		;;
esac

case "$output_dir" in
	-* )
		if [ "$output_dir_handle_dash" = 'leading-dot' ]; then
			output_dir="./$output_dir"
		fi
		;;
esac


archive_path_arg="$(shell_quote "$archive_path")"
archive_path_arg="$(simplify_home "$archive_path_arg")"
output_dir_arg="$(shell_quote "$output_dir")"
output_dir_arg="$(simplify_home "$output_dir_arg")"
password_arg="$(shell_quote "$password")"

base_name="$(basename -- "$archive_path")"
base_name_no_ext="${base_name%$remove_suffix}"
case "$output_dir" in
	'' )
		output_path="$base_name_no_ext"
		;;
	*/ )
		output_path="$output_dir$base_name_no_ext"
		;;
	* )
		output_path="$output_dir/$base_name_no_ext"
		;;
	esac
output_path_arg="$(shell_quote "$output_path")"
output_path_arg="$(simplify_home "$output_path_arg")"


awk_program='{
	gsub("ARCHIVE_PATH", archive_path);
	gsub("OUTPUT_DIR", output_dir);
	gsub("OUTPUT_PATH", output_path);
	gsub("PASSWORD", password);
	print;
}'


# Pretty string starts as bright blue, then reset at the end
# Arguments in pretty string are green, then the following text is bright blue
# Password in pretty string is red

if [ -z "$only_print_command" ]; then
	printf "\033[38;5;12m%s\033[m" "$run" | >&2 awk \
		-v archive_path="$archive_path_arg_prefix\033[38;5;2m$archive_path_arg\033[38;5;12m" \
		-v output_dir="\033[38;5;2m$output_dir_arg\033[38;5;12m" \
		-v output_path="\033[38;5;2m$output_path_arg\033[38;5;12m" \
		-v password="\033[38;5;1mPLAINTEXT_PASSWORD\033[38;5;12m" \
		"$awk_program"
	>&2 echo
fi


run_command="$(printf '%s' "$run" | awk \
	-v archive_path="$archive_path_arg_prefix$archive_path_arg" \
	-v output_dir="$output_dir_arg" \
	-v output_path="$output_path_arg" \
	-v password="$password_arg" \
	"$awk_program")"

if [ -n "$only_print_command" ]; then
	echo "$run_command"
else
	( eval "$run_command" )
fi
