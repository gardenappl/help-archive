#!/bin/sh

set -o errexit


# Sanitize string so it's usable as an argument
shell_quote() {
	escaped=$(echo "$1" | sed "s/'/'\"'\"'/g")

	case "$escaped" in
		'' )
			# Empty string
			;;
		*[![:alnum:]-_\./~]* )
			# Argument contains characters which are not safe
			echo "'$escaped'"
			;;
		* )
			echo "$escaped"
			;;
	esac
}

simplify_home() {
	echo "$1" | awk --assign home="$HOME" '{ sub("^"home, "~"); print }'
}


options=ho:X:p:fdqscS
longopts=help,output-directory:,extract-to:,password:,force,force-overwrite,delete,quiet,force-skip,skip,command,simulate
parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
eval set -- "$parsed"


while true; do
	case "$1" in 
		-o | --output-directory | -X | --extract-to )
			# Get rid of trailing slash
			output_dir="${2%/}"
			shift 2
			;;
		-p | --password )
			password="$2"
			shift 2
			;;
		-f | --force-overwrite | --force )
			force=y
			shift
			;;
		-s | --force-skip | --skip )
			skip=y
			shift
			;;
		-d | --delete )
			delete=y
			shift
			;;
		-q | --quiet )
			quiet=y
			shift
			;;
		-c | --command | -S | --simulate )
			only_print_command=y
			shift
			;;
		-- )
			shift
			archive_path="$1"
			break
			;;
	esac
done

if [ -n "$force" ] && [ -n "$skip" ]; then
	>&2 echo "Error: can't --skip and --force-overwrite at the same time."
	exit 1
fi


# We will manually replace ARCHIVE_PATH, etc with the needed arguments
# (with or without color formatting)

case "$archive_path" in
	*.zip )
		must_rm=y

		run="unzip"

		[ -n "$force" ] && run="$run -o"
		[ -n "$skip" ] && run="$run -n"
		[ -n "$quiet" ] && run="$run -q"
		
		# Handle password which starts with -
		case "$password" in
			'' )
				# No password
				;;
			-* )
				run="$run -PPASSWORD"
				;;
			* )
				run="$run -P PASSWORD"
				;;
		esac

		# Info-ZIP does not recognize --
		archive_path_handle_dash=leading-dot
		run="$run ARCHIVE_PATH"

		[ -n "$output_dir" ] && run="$run -d OUTPUT_DIR"
		;;
	*.rar )
		must_rm=y

		run="unrar x"

		[ -n "$force" ] && run="$run -o+"
		[ -n "$skip" ] && run="$run -o-" # Skips files but sometimes exits with an error anyway, sigh...
		[ -n "$quiet" ] && run="$run -inul"
		[ -n "$password" ] && run="$run -pPASSWORD"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"

		# unrar always treats the last argument as the output dir,
		# but only if it has a trailing slash
		if [ -n "$output_dir" ]; then
			output_dir="$output_dir/"
			run="$run OUTPUT_DIR"
		fi
		;;
	*.tar | *.tar.* | *.tgz | *.tbz | *.txz | *.tlz | *.tzo )
		must_rm=y
		must_mkdir=y

		case "$archive_path" in
			*.tar.gz | *.tgz )
				[ -n "$quiet" ] && run="tar xzf" || run="tar xzvf"
				;;
			*.tar.bz | *.tbz )
				[ -n "$quiet" ] && run="tar xjf" || run="tar xjvf"
				;;
			* )
				[ -n "$quiet" ] && run="tar xf" || run="tar xvf"
				;;
		esac

		# Handle archive path which starts with -
		# We put the --directory argument at the end, so we can't use --
		archive_path_handle_dash=leading-dot
		run="$run ARCHIVE_PATH"

		# Skip existing files by default.
		# No need to handle --skip option.
		[ -z "$force" ] && run="$run --skip-old-files"
		[ -n "$output_dir" ] && run="$run --directory=OUTPUT_DIR"
		;;
	?*.bz2 | ?*.bz | ?*.gz | ?*.xz | ?*.lzma )
		must_mkdir=y
		must_test_existing=y

		case "$archive_path" in
			*.bz )
				remove_suffix='.bz'
				run="bunzip2"
				;;
			*.bz2 )
				remove_suffix='.bz2'
				run="bunzip2"
				;;
			*.gz )
				remove_suffix='.gz'
				run="gunzip"
				;;
			*.xz )
				remove_suffix='.xz'
				run="unxz"
				;;
			*.lzma )
				remove_suffix='.lzma'
				run="unlzma"
				;;
		esac

		[ -z "$delete" ] && run="$run --keep"
		[ -n "$force" ] && run="$run --force"

		archive_path_handle_dash=double-dash
		if [ -n "$output_dir" ]; then
			run="$run --stdout ARCHIVE_PATH > OUTPUT_PATH"
		else
			run="$run ARCHIVE_PATH"
		fi
		;;
	?*.lz )
		must_mkdir=y
		must_test_existing=y
		remove_suffix='.lz'

		[ -n "$force" ] && run="$run --force"

		if [ -n "$output_dir" ]; then
			must_rm=y
			run="lzip -d --output=OUTPUT_PATH"
		elif [ -n "$delete" ]; then
			run="lzip -d"
		else
			run="lzip -d --keep"
		fi

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
	?*.lzo )
		must_mkdir=y
		must_test_existing=y

		run="lzop -x"

		[ -n "$delete" ] && run="$run --delete"
		[ -n "$force" ] && run="$run --force"

		output_dir_handle_dash=leading-dot
		[ -n "$output_dir" ] && run="$run --path=OUTPUT_DIR"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
	?*.Z )
		must_mkdir=y
		must_test_existing=y
		remove_suffix='.Z'

		run="uncompress"

		[ -n "$force" ] && run="$run -f"

		# Let's be strictly POSIX-compliant in the case of .Z
		archive_path_handle_dash=leading-dot
		if [ -z "$delete" ] || [ -n "$output_path" ]; then
			run="$run -c ARCHIVE_PATH > OUTPUT_PATH"
		else
			run="$run ARCHIVE_PATH"
		fi
		;;
	* )
		case "$archive_path" in
			*.7z )
				# Using 7z is perfectly fine
				;;
			* )
				>&2 echo "Don't know the proper tool for $archive_path, let's just try 7z"
				;;
		esac

		must_rm=y

		run="7z x"

		[ -n "$force" ] && run="$run -aoa"
		[ -n "$skip" ] && run="$run -aos"
		[ -n "$output_dir" ] && run="$run -oOUTPUT_DIR"
		[ -n "$password" ] && run="$run -pPASSWORD"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
esac

# Manually remove archive on successful extraction
if [ -n "$must_rm" ] && [ -n "$delete" ]; then
	case "$archive_path" in
		-* )
			run="$run && rm -- $archive_path"
			;;
		* )
			run="$run && rm $archive_path"
			;;
	esac
	used_and=y
fi

if [ -n "$must_test_existing" ] && [ -n "$skip" ]; then
	if [ -n "$used_and" ]; then
		run="[ -e OUTPUT_PATH ] || ( $run )"
	else
		run="[ -e OUTPUT_PATH ] || $run"
	fi
fi

# Manually create output directory
if [ -n "$must_mkdir" ]; then
	# Handle output dir which starts with -
	case "$output_dir" in
		'' )
			# No output dir
			;;
		-* )
			run="mkdir -p -- OUTPUT_DIR\n$run"
			;;
		* )
			run="mkdir -p OUTPUT_DIR\n$run"
			;;
	esac
fi


case "$archive_path" in
	-* )
		if [ "$archive_path_handle_dash" = 'double-dash' ]; then
			archive_path_arg_prefix="-- "
		elif [ "$archive_path_handle_dash" = 'leading-dot' ]; then
			archive_path="./$archive_path"
		fi
		;;
	* )
		;;
esac

case "$output_dir" in
	-* )
		if [ "$output_dir_handle_dash" = 'leading-dot' ]; then
			output_dir="./$output_dir"
		fi
		;;
esac


archive_path_arg="$(shell_quote "$archive_path")"
archive_path_arg="$(simplify_home "$archive_path_arg")"
output_dir_arg="$(shell_quote "$output_dir")"
output_dir_arg="$(simplify_home "$output_dir_arg")"
password_arg="$(shell_quote "$password")"

base_name="$(basename -- "$archive_path")"
base_name_no_ext="${base_name%$remove_suffix}"
case "$output_dir" in
	'' )
		output_path="$base_name_no_ext"
		;;
	*/ )
		output_path="$output_dir$base_name_no_ext"
		;;
	* )
		output_path="$output_dir/$base_name_no_ext"
		;;
esac
output_path_arg="$(shell_quote "$output_path")"


awk_program='{
	gsub("ARCHIVE_PATH", archive_path);
	gsub("OUTPUT_DIR", output_dir);
	gsub("OUTPUT_PATH", output_path);
	gsub("PASSWORD", password);
	print;
}'


# Pretty string starts as bright blue, then reset at the end
# Arguments in pretty string are green, then the following text is bright blue
# Password in pretty string is red

if [ -z "$only_print_command" ]; then
	echo "\033[38;5;12m$run\033[m" | >&2 awk \
		--assign archive_path="$archive_path_arg_prefix\033[38;5;2m$archive_path_arg\033[38;5;12m" \
		--assign output_dir="\033[38;5;2m$output_dir_arg\033[38;5;12m" \
		--assign output_path="\033[38;5;2m$output_path_arg\033[38;5;12m" \
		--assign password="\033[38;5;1mPLAINTEXT_PASSWORD\033[38;5;12m" \
		"$awk_program"
	>&2 echo
fi


run_command="$(echo "$run" | awk \
	--assign archive_path="$archive_path_arg_prefix$archive_path_arg" \
	--assign output_dir="$output_dir_arg" \
	--assign output_path="$output_path_arg" \
	--assign password="$password_arg" \
	"$awk_program")"

if [ -n "$only_print_command" ]; then
	echo "$run_command"
else
	( eval "$run_command" )
fi
