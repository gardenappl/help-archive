#!/bin/sh

set -o errexit

# Function from dylanaraps' pure sh bible
# shellcheck disable=SC2086,SC2048
trim_all() {
	# Usage: trim_all "   example   string    "

	# Disable globbing to make the word-splitting below safe.
	set -f

	# Set the argument list to the word-splitted string.
	# This removes all leading/trailing white-space and reduces
	# all instances of multiple spaces to a single ("  " -> " ").
	set -- $*

	# Print the argument list as a string.
	printf '%s\n' "$*"

	# Re-enable globbing.
	set +f
}

quote_if_needed() {
	# Check if argument has whitespace
	case "$(trim_all "$1")" in
		*' '* )
			echo "'$1'"
			;;
		* )
			echo "$1"
			;;
	esac
}

simplify_home() {
	echo "$1" | awk --assign home="$HOME" '{ sub("^"home, "~"); print }'
}


options=ho:X:p:fdq
longopts=help,output-directory:,extract-to:,password:,force,force-overwrite,delete,quiet
parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
eval set -- "$parsed"


while true; do
	case "$1" in 
		-o | --output-directory | -X | --extract-to )
			# Get rid of trailing slash
			output_dir="${2%/}"
			shift 2
			;;
		-p | --password )
			password="$2"
			shift 2
			;;
		-f | --force-overwrite | --force )
			force=y
			shift
			;;
		-d | --delete )
			delete=y
			shift
			;;
		-q | --quiet )
			quiet=y
			shift
			;;
		-- )
			shift
			archive_path="$1"
			break
			;;
	esac
done


# We will manually replace ARCHIVE_PATH, etc with the needed arguments
# (with or without color formatting)

case "$archive_path" in
	*.zip )
		must_rm=y

		run="unzip"

		[ -n "$force" ] && run="$run -o"
		[ -n "$quiet" ] && run="$run -q"
		
		# Handle password which starts with -
		case "$password" in
			'' )
				# No password
				;;
			-* )
				run="$run -PPASSWORD"
				;;
			* )
				run="$run -P PASSWORD"
				;;
		esac

		# Info-ZIP does not recognize --
		archive_path_handle_dash=leading-dot
		run="$run ARCHIVE_PATH"

		[ -n "$output_dir" ] && run="$run -d OUTPUT_DIR"
		;;
	*.rar )
		must_rm=y

		run="unrar x"

		[ -n "$force" ] && run="$run -o+"
		[ -n "$quiet" ] && run="$run -inul"
		[ -n "$password" ] && run="$run -pPASSWORD"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"

		# unrar always treats the last argument as the output dir,
		# but only if it has a trailing slash
		if [ -n "$output_dir" ]; then
			output_dir="$output_dir/"
			run="$run OUTPUT_DIR"
		fi
		;;
	*.tar | *.tar.* | *.tgz | *.tbz | *.txz | *.tlz | *.tzo )
		must_rm=y
		must_mkdir=y

		# tar always overwrites files, there's no need to handle --force

		case "$archive_path" in
			*.tar.gz | *.tgz )
				[ -n "$quiet" ] && run="tar xzf" || run="tar xzvf"
				;;
			*.tar.bz | *.tbz )
				[ -n "$quiet" ] && run="tar xjf" || run="tar xjvf"
				;;
			* )
				[ -n "$quiet" ] && run="tar xf" || run="tar xvf"
				;;
		esac

		# Handle archive path which starts with -
		# We put the --directory argument at the end, so we can't use --
		archive_path_handle_dash=leading-dot
		run="$run ARCHIVE_PATH"

		[ -z "$force" ] && run="$run --skip-old-files"
		[ -n "$output_dir" ] && run="$run --directory=OUTPUT_DIR"
		;;
	*.bz2 | *.bz | *.gz | *.xz | *.lzma )
		must_mkdir=y

		case "$archive_path" in
			*.bz )
				remove_suffix='.bz'
				run="bunzip2"
				;;
			*.bz2 )
				remove_suffix='.bz2'
				run="bunzip2"
				;;
			*.gz )
				remove_suffix='.gz'
				run="gunzip"
				;;
			*.xz )
				remove_suffix='.xz'
				run="unxz"
				;;
			*.lzma )
				remove_suffix='.lzma'
				run="unlzma"
				;;
		esac

		[ -z "$delete" ] && run="$run --keep"
		[ -n "$force" ] && run="$run --force"

		archive_path_handle_dash=double-dash
		if [ -n "$output_dir" ]; then
			run="$run --stdout ARCHIVE_PATH > OUTPUT_PATH"
		else
			run="$run ARCHIVE_PATH"
		fi
		;;
	*.lz )
		must_mkdir=y
		remove_suffix='.lz'

		[ -n "$force" ] && run="$run --force"

		if [ -n "$output_dir" ]; then
			must_rm=y
			run="lzip -d --output=OUTPUT_PATH"
		elif [ -n "$delete" ]; then
			run="lzip -d"
		else
			run="lzip -d --keep"
		fi

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
	*.lzo )
		must_mkdir=y

		run="lzop -x"

		[ -n "$delete" ] && run="$run --delete"
		[ -n "$force" ] && run="$run --force"

		output_dir_handle_dash=leading-dot
		[ -n "$output_dir" ] && run="$run --path=OUTPUT_DIR"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
	*.Z )
		must_mkdir=y
		remove_suffix='.Z'

		run="uncompress"

		[ -n "$force" ] && run="$run -f"

		# Let's be strictly POSIX-compliant in the case of .Z
		archive_path_handle_dash=leading-dot
		if [ -z "$delete" -o -n "$output_path" ]; then
			run="$run -c ARCHIVE_PATH > OUTPUT_PATH"
		else
			run="$run ARCHIVE_PATH"
		fi
		;;
	* )
		case "$archive_path" in
			*.7z )
				# Using 7z is perfectly fine
				;;
			* )
				>&2 echo "Don't know the proper tool for $archive_path, let's just try 7z"
				;;
		esac

		must_rm=y

		run="7z x"

		[ -n "$force" ] && run="$run -aoa"
		[ -n "$output_dir" ] && run="$run -oOUTPUT_DIR"
		[ -n "$password" ] && run="$run -pPASSWORD"

		archive_path_handle_dash=double-dash
		run="$run ARCHIVE_PATH"
		;;
esac

# Manually remove archive on successful extraction
if [ -n "$must_rm" -a -n "$delete" ]; then
	case "$archive_path" in
		-* )
			run="$run && rm -- $archive_path"
			;;
		* )
			run="$run && rm $archive_path"
			;;
	esac
fi

# Manually create output directory
if [ -n "$must_mkdir" ]; then
	# Handle output dir which starts with -
	case "$output_dir" in
		'' )
			# No output dir
			;;
		-* )
			run="mkdir -p -- OUTPUT_DIR\n$run"
			;;
		* )
			run="mkdir -p OUTPUT_DIR\n$run"
			;;
	esac
fi


case "$archive_path" in
	-* )
		if [ "$archive_path_handle_dash" = 'double-dash' ]; then
			archive_path_arg_prefix="-- "
		elif [ "$archive_path_handle_dash" = 'leading-dot' ]; then
			archive_path="./$archive_path"
		fi
		;;
	* )
		;;
esac

case "$output_dir" in
	-* )
		if [ "$output_dir_handle_dash" = 'leading-dot' ]; then
			output_dir="./$output_dir"
		fi
		;;
esac


archive_path_arg="$(quote_if_needed "$archive_path")"
archive_path_arg="$(simplify_home "$archive_path_arg")"
output_dir_arg="$(quote_if_needed "$output_dir")"
output_dir_arg="$(simplify_home "$output_dir_arg")"
password_arg="$(quote_if_needed "$password")"

base_name="$(basename -- "$archive_path")"
base_name_no_ext="${base_name%$remove_suffix}"
case "$output_dir" in
	'' )
		output_path="$base_name_no_ext"
		;;
	*/ )
		output_path="$output_dir$base_name_no_ext"
		;;
	* )
		output_path="$output_dir/$base_name_no_ext"
		;;
esac
output_path_arg="$(quote_if_needed "$output_path")"


awk_program='{
	gsub("ARCHIVE_PATH", archive_path);
	gsub("OUTPUT_DIR", output_dir);
	gsub("OUTPUT_PATH", output_path);
	gsub("PASSWORD", password);
	print;
}'


# Pretty string starts as bright blue, then reset at the end
# Arguments in pretty string are green, then the following text is bright blue
# Password in pretty string is red

echo "\033[38;5;12m$run\033[m" | >&2 awk \
	--assign archive_path="$archive_path_arg_prefix\033[38;5;2m$archive_path_arg\033[38;5;12m" \
	--assign output_dir="\033[38;5;2m$output_dir_arg\033[38;5;12m" \
	--assign output_path="\033[38;5;2m$output_path_arg\033[38;5;12m" \
	--assign password="\033[38;5;1mPLAINTEXT_PASSWORD\033[38;5;12m" \
	"$awk_program"
>&2 echo


run_command="$(echo "$run" | awk \
	--assign archive_path="$archive_path_arg_prefix$archive_path_arg" \
	--assign output_dir="$output_dir_arg" \
	--assign output_path="$output_path_arg" \
	--assign password="$password_arg" \
	"$awk_program")"

( eval "$run_command" )
